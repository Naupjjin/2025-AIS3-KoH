<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <title>Rules</title>
    <!-- GitHub Markdown Style -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css">
    <style>
        body {
            background: #f5f7fa;
            font-family: "Segoe UI", "Noto Sans TC", sans-serif;
            margin: 0;
        }
        .content {
            max-width: 1000px;
            margin: 50px auto;
            padding: 40px 60px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
        }
        .markdown-body h1,
        .markdown-body h2,
        .markdown-body h3 {
            border-bottom: 1px solid #eee;
            padding-bottom: 6px;
            margin-top: 32px;
        }
        .markdown-body p {
            line-height: 1.8;
            margin: 12px 0;
        }
        table {
            background-color: white !important;
            color: black !important;
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            background-color: white !important;
            color: black !important;
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }
        pre code {
            display: block;
            background: #f6f8fa;
            padding: 16px;
            border-radius: 8px;
            font-size: 14px;
            overflow-x: auto;
        }
        ul {
            margin-left: 20px;
        }
        .content.markdown-body {
            color: #24292f; /* GitHub markdown 正常文字顏色 */
        }
    </style>
</head>
<body>
    {% include "sidebar.html" %}
    <div class="content markdown-body">
        <h1>Mortis GO!!!!!</h1>
        <a href="https://hackmd.io/@naup96321/Skz2n5_Dex">
            hackmd version
        </a>
        <p>小睦因為太久沒上學所以跟不上進度，只好分裂出多重人格找小祥補進度
        小祥會給小睦的不同人格題目，解出來就能獲得分數
        或是也可以選擇幹掉其他的人格，在多重人格大逃殺中吃雞</p>
        <h2>玩法</h2>
        <p>隊伍通過上傳 assembly (詳見指令集) 來遊玩遊戲，1 round 遊戲共有 200 turn，每 turn 都會去執行同一段 assembly，並回傳一個指令 (詳見指令)
        每五分鐘為 1 round，這裡稱作 active，並且 round 與 round 中間會有時長不一的 pending，玩家只能在 active 時上傳腳本，若無上傳新腳本，則會沿用之前提交的最新腳本
        模擬後會根據遊戲分數進行排名轉換成實際分數 (詳見計分方式)</p>
        <p>ex:
        round 31 active 時上傳腳本 --&gt; round 31 pending 等待進入 round 32 --&gt; round 32 active 模擬該 round 前上傳的最新腳本並更新分數 (模擬時間長短不一，請耐心等候) </p>
        <h2>計分方式</h2>
        <h3>Scoreboard 分數</h3>
        <p>每 round 會去跑玩家上傳的 assembly，並統計該輪遊戲獲得的分數，排名後會轉換成會記錄在 scoreboard 上的分數
        轉換方是如下:</p>
        <table>
        <thead>
        <tr>
        <th>Rank</th>
        <th>Score (scorebboard)</th>
        </tr>
        </thead>
        <tbody><tr>
        <td>1</td>
        <td>30</td>
        </tr>
        <tr>
        <td>2</td>
        <td>20</td>
        </tr>
        <tr>
        <td>3</td>
        <td>15</td>
        </tr>
        <tr>
        <td>4、5</td>
        <td>8</td>
        </tr>
        <tr>
        <td>6、7</td>
        <td>3</td>
        </tr>
        <tr>
        <td>8、9、10</td>
        <td>1</td>
        </tr>
        </tbody></table>
        <p>若該 round 沒有拿到任何分數以 0 分計算
        同分狀況則如下轉換:</p>
        <p>team 8、4 遊戲分數 52 分
        team 9 遊戲分數 48 分
        team 1、2、7 遊戲分數 6 分</p>
        <p>則
        team 8、4 並列第一名拿到 30 分
        跳過第二名
        team 9 第三名拿到 20 分
        team 1、2、7 第四名拿到 8 分</p>
        <h3>遊戲分數</h3>
        <p>通過編寫 assembly，可以操控玩家並互動地圖上的物件
        可以通過以下方式來獲取分數</p>
        <ul>
        <li>移動(1 分): 若該 turn 有移動玩家 (本體、分身)</li>
        <li>殺人:<ul>
        <li>擊殺本體 (70 分): 本體共有 3 滴血，若你成功擊殺別支隊伍本體可得分</li>
        <li>擊殺分身 (40 分): 分身共有 2 滴血，若你成功擊殺別支隊伍分身可得分</li>
        </ul>
        </li>
        <li>小祥: 通過互動可以拿到任務，會將任務相關資訊放置在記憶體上，之後將任務需求放置到對應記憶體上，再次互動，若正確即可得分，共有以下幾種任務，分別有不同分數<ul>
        <li>1 反轉數字 (30 分): 7 個參數，7 個答案 (ex: 123456 (七個) 反轉成 654321)</li>
        <li>2 排序 (40 分): 7 個參數，7 個答案 (ex: 2、5、4、1、6、3 排序成 1、2、3、4、5、6)</li>
        <li>3 RSA 解密 (50 分): 4 個參數 (p、q、e、c)，1 個答案 (m)</li>
        <li>4 ECC 點加法 (60 分): 7 個參數(a、b、p、P_x、P_y、Q_x、Q_y)，2 個答案 (R_X、R_y)，給定曲線 y^2=x^3+ax+b (mod p)，計算曲線上兩個 P、Q 之 P+Q = R 為多少</li>
        </ul>
        </li>
        </ul>
        <p>buf[50] 題目編號
        buf[51] ~ buf[57] 按順序放置參數及答案</p>
        <h2>記憶體</h2>
        <p>玩家有 100 格可以存 unsigned int 的記憶體</p>
        <ul>
        <li>buf[0] ~ buf[49] 玩家與分身共用，會繼承</li>
        <li>buf[50] ~ buf[57] 玩家及分身自己用，會繼承</li>
        <li>buf[58] ~ buf[99] 玩家及分身自己用，不會繼承</li>
        <li>buf[58] pid 若為 fork，則 pid = 0</li>
        <li>buf[60] ~ buf[67] 周遭 8 格的資訊，從上面一格順時鐘填入<ul>
        <li>資訊透過 or 將周遭資訊填入</li>
        <li>WALL = 1, CHEST = 2, CHARACTER = 4</li>
        <li>ex: 同一格有角色同時有箱子, 則 buf[60] 的值是 6</li>
        </ul>
        </li>
        </ul>
        <h2>地圖</h2>
        <p>每 5 round 會刷新地圖 (ex: 1~5 round 為第一張、6~10 為第二張，以此類推)
        當模擬完畢後，可以在 <code>game</code> 的地方看到該輪模擬結果</p>
        <ul>
        <li>按 <code>1</code> 可以追蹤一個玩家</li>
        <li>按 <code>2</code> 回到全地圖</li>
        <li>按 <code>+</code> 可以看到下一 turn</li>
        <li>按 <code>-</code> 可以看到上一 turn</li>
        <li>按 <code>shift</code> 和 <code>+</code> 可以加速進行 (本地測試提供)</li>
        </ul>
        <h2>指令</h2>
        <p>玩家可以透過不同的 Instruction 來操控記憶體或是控制程式流程
        並在最後透過 ret 回傳不同的數字來控制 Mortis</p>
        <table>
        <thead>
        <tr>
        <th>number</th>
        <th>指令</th>
        <th>描述</th>
        </tr>
        </thead>
        <tbody><tr>
        <td>0</td>
        <td>stop</td>
        <td>無動作</td>
        </tr>
        <tr>
        <td>1</td>
        <td>up</td>
        <td>往上走一格</td>
        </tr>
        <tr>
        <td>2</td>
        <td>down</td>
        <td>往下走一格</td>
        </tr>
        <tr>
        <td>3</td>
        <td>left</td>
        <td>往左走一格</td>
        </tr>
        <tr>
        <td>4</td>
        <td>right</td>
        <td>往右走一格</td>
        </tr>
        <tr>
        <td>5</td>
        <td>interact</td>
        <td>跟周圍 8 格寶箱互動 (不包含自身所在位置)</td>
        </tr>
        <tr>
        <td>6</td>
        <td>attack</td>
        <td>攻擊周圍 8 格 (不包含自身所在位置)</td>
        </tr>
        <tr>
        <td>7</td>
        <td>fork</td>
        <td>在原地分身</td>
        </tr>
        </tbody></table>
        <p>備註: assembly 每 turn timeout 上限為 250 ms，若該 turn timeout 則會直接回傳 0</p>
        <h2>角色</h2>
        <p>玩家本體會有 3 滴血，而分身會有 2 滴血
        本體死後會在隨機位置重生，分身則會消失</p>
        <h2>fork</h2>
        <p>當執行 fork 時，玩家可以在原地產生分身
        基礎消耗是 70 
        一個玩家可以最多有 3 個分身，並且每次 fork 時，所需的分數就會變成 1.2 倍，
        fork 會執行跟一開始的角色一樣的 assembly</p>
        <h2>指令集</h2>
        <ul>
        <li>memory: 以 memX 表示，例如 mem0, mem1，撰寫時使用 index，ex: <code>1</code>、<code>83</code></li>
        <li>constant: 以前綴 <code>#</code> 標示，ex: <code>#1</code>、<code>#83</code></li>
        <li>label: 任意 label 名稱，並在結尾加上 <code>:</code>，ex: <code>avemujica:</code></li>
        </ul>
        <table>
        <thead>
        <tr>
        <th>指令</th>
        <th>說明</th>
        </tr>
        </thead>
        <tbody><tr>
        <td><code>mov &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 = mem2</code></td>
        </tr>
        <tr>
        <td><code>mov &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 = constant</code></td>
        </tr>
        <tr>
        <td><code>movi &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>*mem1 = *mem2</code></td>
        </tr>
        <tr>
        <td><code>add &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 += mem2</code></td>
        </tr>
        <tr>
        <td><code>add &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 += constant</code></td>
        </tr>
        <tr>
        <td><code>shr &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 &gt;&gt;= mem2</code></td>
        </tr>
        <tr>
        <td><code>shr &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 &gt;&gt;= constant</code></td>
        </tr>
        <tr>
        <td><code>shl &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 &lt;&lt;= mem2</code></td>
        </tr>
        <tr>
        <td><code>shl &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 &lt;&lt;= constant</code></td>
        </tr>
        <tr>
        <td><code>mul &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 *= mem2</code></td>
        </tr>
        <tr>
        <td><code>mul &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 *= constant</code></td>
        </tr>
        <tr>
        <td><code>div &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 /= mem2</code></td>
        </tr>
        <tr>
        <td><code>div &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 /= constant</code></td>
        </tr>
        <tr>
        <td><code>je &lt;mem1&gt; &lt;mem2&gt; $&lt;label&gt;</code></td>
        <td>若 <code>mem1 == mem2</code> 則跳轉至 <code>&lt;label&gt;</code></td>
        </tr>
        <tr>
        <td><code>je &lt;mem1&gt; #&lt;constant&gt; $&lt;label&gt;</code></td>
        <td>若 <code>mem1 == constant</code> 則跳轉至 <code>&lt;label&gt;</code></td>
        </tr>
        <tr>
        <td><code>jg &lt;mem1&gt; &lt;mem2&gt; &lt;label&gt;</code></td>
        <td>若 <code>mem1 &gt; mem2</code> 則跳轉至 <code>&lt;label&gt;</code></td>
        </tr>
        <tr>
        <td><code>jg &lt;mem1&gt; #&lt;constant&gt; $&lt;label&gt;</code></td>
        <td>若 <code>mem1 &gt; constant</code> 則跳轉至 <code>&lt;label&gt;</code></td>
        </tr>
        <tr>
        <td><code>inc &lt;mem1&gt;</code></td>
        <td><code>mem1++</code></td>
        </tr>
        <tr>
        <td><code>dec &lt;mem1&gt;</code></td>
        <td><code>mem1--</code></td>
        </tr>
        <tr>
        <td><code>and &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 &amp;= mem2</code></td>
        </tr>
        <tr>
        <td><code>and &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 &amp;= constant</code></td>
        </tr>
        <tr>
        <td><code>or &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td><code>mem1 |= mem2</code></td>
        </tr>
        <tr>
        <td><code>or &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td><code>mem1 |= constant</code></td>
        </tr>
        <tr>
        <td><code>ng &lt;mem1&gt;</code></td>
        <td><code>mem1 = ~mem1</code></td>
        </tr>
        <tr>
        <td><code>ret &lt;mem1&gt;</code></td>
        <td>結束並返回 <code>mem1</code> 的值 (返回值就是指令)</td>
        </tr>
        <tr>
        <td><code>ret #&lt;constant&gt;</code></td>
        <td>結束並返回常數 (返回值就是指令)</td>
        </tr>
        <tr>
        <td><code>load_score &lt;mem1&gt;</code></td>
        <td>將當前分數載入 <code>mem1</code></td>
        </tr>
        <tr>
        <td><code>get_id &lt;mem1&gt;</code></td>
        <td>將角色 ID 載入 <code>mem1</code></td>
        </tr>
        <tr>
        <td><code>locate_nearest_k_chest &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td>將距離第 <code>mem2</code> 個最近寶箱的座標 <code>(x,y)</code> 存入 <code>mem1[0]</code> 與 <code>mem1[1]</code></td>
        </tr>
        <tr>
        <td><code>locate_nearest_k_chest &lt;mem1&gt; #&lt;constant&gt;</code></td>
        <td>將距離第 <code>constant</code> 個最近寶箱的座標 <code>(x,y)</code> 存入 <code>mem1[0]</code> 與 <code>mem1[1]</code></td>
        </tr>
        <tr>
        <td><code>locate_nearest_k_character &lt;mem1&gt; &lt;mem2&gt;</code></td>
        <td>將距離第 <code>mem2</code> 個最近角色的資訊存入 <code>mem1[0..2]</code>，分別是 <code>is_fork</code>、  <code>(x,y)</code></td>
        </tr>
        </tbody></table>
        <h2>本地測試</h2>
        <pre><code>├── app.py
        ├── Makefile
        ├── maps
            └── gen_map.py
        ├── simulator.py
        ├── static
        ├── templates
        └── vm
            ├── vm.cpp
            └── vm.h
        </code></pre>
        <p>提供可以進行本地測試的檔案，可以將 <code>app.py</code> 跑起來
        備註1 : 在跑網頁前，需先 <code>make</code> 將 <code>vm</code> 編譯好
        備註2 : 通過 <code>maps/gen_map.py</code> 產生的地圖可以作為本地測試用，但會產生封閉區域，不過這邊確保遠端的地圖沒有封閉區域 </p>
        
    </div>
</body>
</html>
